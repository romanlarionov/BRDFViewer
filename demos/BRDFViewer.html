<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Ideal Mirror Reflection Program</title>
        <style>
            body {
				color: #000;
				font-family:Monospace;
				font-size:20px;
				text-align:center;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			canvas { width: 100%; height: 100% }
            #info {
                position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
            }
		</style>
	</head>
	<body>

    <div id="container"></div>
	<div id="info">BRDF Viewer</div>

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r80/three.min.js"></script>
    <script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
	<script src="../assets/ltc_tables.js" type="text/javascript"></script>
    <script src='../lib/DAT.GUI.min.js' type='text/javascript'></script>
	<script src="../src/js/model.js" type="text/javascript"></script>
	<script src="../src/js/shader.js" type="text/javascript"></script>
    <script>
        // Set up three.js render context
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0.0, 5.0, 5.0);
        var cameraSpeed = 10;
        var clock = new THREE.Clock();
        var deltaTime;
        
        var ambient = new THREE.AmbientLight(0xFFFFFF);
		scene.add(ambient);

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        window.addEventListener("resize", onWindowResize, false);
        document.body.appendChild(renderer.domElement);
        scene.background = new THREE.Color(0x3C5C67);

        // User Input
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;
		controls.dampingFactor = 0.25;
		controls.enableZoom = false;

        // Scene objects
        var gridHelper = new THREE.GridHelper(25, 50, 0x60F4E1, 0xE7EDEC);
        scene.add(gridHelper);

        // todo: remove ltc stuff
        /*var ltc_mat_data = new Float32Array(g_ltc_mat);
        var ltc_mat_tex = new THREE.DataTexture(ltc_mat_data, 64, 64, THREE.RGBAFormat, THREE.FloatType);
        ltc_mat_tex.minFilter = THREE.NearestFilter;
        ltc_mat_tex.magFilter = THREE.LinearFilter;
        ltc_mat_tex.wrapS = THREE.ClampToEdgeWrapping;
        ltc_mat_tex.wrapT = THREE.ClampToEdgeWrapping;
        ltc_mat_tex.needsUpdate = true;

        var ltc_amp_data = new Float32Array(g_ltc_mag);
        var ltc_amp_tex = new THREE.DataTexture(ltc_amp_data, 64, 64, THREE.AlphaFormat, THREE.FloatType);
        ltc_amp_tex.minFilter = THREE.NearestFilter;
        ltc_amp_tex.magFilter = THREE.LinearFilter;
        ltc_amp_tex.wrapS = THREE.ClampToEdgeWrapping;
        ltc_amp_tex.wrapT = THREE.ClampToEdgeWrapping;
        ltc_amp_tex.needsUpdate = true;*/

        /*var ltcMaterial = new Shader("ltc", "ltc", {
            shading_light : {type: 'v3', value: new THREE.Vector3(5.0, 20.0, 20.0)},
            shading_intensity : {type: 'v3', value: new THREE.Vector3(0.5, 0.5, 0.5)},
            shading_color : {type: 'v3', value: new THREE.Vector3(0.2, 0.2, 1.0)},
            roughness : {type: 'f', value: 0.3 },
            theta : {type: 'f', value: Math.PI / 4},
            F0 : {type: 'f', value: 0.1 },
            plotLog : {type: 'f', value: 0.0 },
            ltc_Minv : {type: 't', value: ltc_mat_tex },
            ltc_Amp : {type: 't', value: ltc_amp_tex }
        });*/

        //var sphereLTC = new THREE.Mesh(sphereGeometry, ltcMaterial.material);
        //scene.add(sphereLTC);

        var sphereFunc = function(u, v) {
            var phi = v * 2 * Math.PI ;
            var theta = u * Math.PI;

            var vert = new THREE.Vector3();
            vert.x = Math.sin(phi) * Math.cos(theta);
            vert.y = Math.sin(phi) * Math.sin(theta);
            vert.z = Math.cos(phi);
            return vert;
        };

        var vertSubdivisions = 500;
        var horiSubdivisions = 500;
        var sphereGeometry = new THREE.ParametricGeometry(sphereFunc, horiSubdivisions, vertSubdivisions);
        sphereGeometry.computeVertexNormals();

        var basicUniforms = {
            shading_light : {type: 'v3', value: new THREE.Vector3(5.0, 20.0, 20.0)},
            shading_intensity : {type: 'v3', value: new THREE.Vector3(0.5, 0.5, 0.5)},
            shading_color : {type: 'v3', value: new THREE.Vector3(0.2, 0.2, 1.0)},
            roughness : {type: 'f', value: 0.3 },
            phi : {type: 'f', value: 0.0 },
            theta : {type: 'f', value: Math.PI / 4},
            F0 : {type: 'f', value: 0.1 },
            plotLog : {type: 'f', value: 0.0 }
        };

        var GGXSmithMaterial      = new Shader("GGXSmith", "basic", basicUniforms);
        var BeckmannMaterial      = new Shader("Beckmann", "basic", basicUniforms);
        var DisneyDiffuseMaterial = new Shader("DisneyDiffuse", "basic", basicUniforms);
        var PhongMaterial         = new Shader("Phong", "basic", basicUniforms);
        var BlinnPhongMaterial    = new Shader("BlinnPhong", "basic", basicUniforms);

        var GGXSmithSphere      = new THREE.Mesh(sphereGeometry, GGXSmithMaterial.material);
        var BeckmannSphere      = new THREE.Mesh(sphereGeometry, BeckmannMaterial.material);
        var DisneyDiffuseSphere = new THREE.Mesh(sphereGeometry, DisneyDiffuseMaterial.material);
        var PhongSphere         = new THREE.Mesh(sphereGeometry, PhongMaterial.material);
        var BlinnPhongSphere    = new THREE.Mesh(sphereGeometry, BlinnPhongMaterial.material);
        scene.add(GGXSmithSphere);

        function updateScene()
        {
        }

        // Render
        function render() {
            requestAnimationFrame(render);
            controls.update();
            updateScene();
            renderer.render(scene, camera);
        }

        function onWindowResize(event) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innderHeight);
        }

        var prev;
        function setupGUI() {
            var brdfTypes = { GGXSmith: 0, Beckmann: 1, DisneyDiffuse: 2, Phong: 3, BlinnPhong: 4};
            var brdfList = [GGXSmithSphere, BeckmannSphere, DisneyDiffuseSphere, PhongSphere, BlinnPhongSphere];

            var updateUniforms = function(param, obj) {
                for (var i = 0; i < brdfList.length; i++) {
                    brdfList[i].material.uniforms[param] = obj;
                }
            };

            var gui = new dat.GUI({ height: 5 * 32 - 1 });

            var params = {
                brdf: 0,
                roughness: 0.3,
                phi: 2 * Math.PI,
                theta: Math.PI / 4.0,
                F0: 0.1,
                plotLog: false
            }

            gui.add(params, 'brdf', brdfTypes).onChange(function(b) {
                scene.remove(brdfList[prev]);
                scene.add(brdfList[b]);
                prev = b;
            });

            gui.add(params, "roughness", 0.0, 1.0).onChange(function(r) {
                updateUniforms("roughness", {type: 'f', value: r });
            });

            // gui.add(params, "phi", 0.0, 2.0 * Math.PI).onChange(function(p) {
                // sphere.material.uniforms["phi"] = {type: 'f', value: p };
                // sphereLTC.material.uniforms["phi"] = {type: 'f', value: p };
            // });

            gui.add(params, "theta", 0.0, Math.PI / 2.0).onChange(function(t) {
                updateUniforms("theta", {type: 'f', value: t });
            });

            gui.add(params, "F0", 0.0, Math.PI / 2.0).onChange(function(f) {
                updateUniforms("F0", {type: 'f', value: f });
            });

            gui.add(params, "plotLog").onChange(function(p) {
                updateUniforms("plotLog", {type: 'f', value: ( (p) ? 1.0 : 0.0) });
            });
        }

        setupGUI();
        render();
	</script>
	</body>
</html>